// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INCLUDES
#include "RobotMap.h"
#include "LiveWindow/LiveWindow.h"
#include "Custom/MultiSpeedController.h"

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INCLUDES

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=ALLOCATION
std::shared_ptr<Encoder> RobotMap::driveTraindBaseEncoderL;
std::shared_ptr<Encoder> RobotMap::driveTraindBaseEncoderR;
std::shared_ptr<SpeedController> RobotMap::driveTraindBaseL;
std::shared_ptr<SpeedController> RobotMap::driveTraindBaseR;
std::shared_ptr<AnalogGyro> RobotMap::driveTraindBaseGyro;
std::shared_ptr<DigitalInput> RobotMap::gearergearDetect;
std::shared_ptr<SpeedController> RobotMap::gearergearRoller;
std::shared_ptr<DoubleSolenoid> RobotMap::gearergearSolenoid1;
std::shared_ptr<DoubleSolenoid> RobotMap::gearergearSolenoid2;
std::shared_ptr<SpeedController> RobotMap::ballCollectorintakeRoller;
std::shared_ptr<DoubleSolenoid> RobotMap::ballCollectorcollectorSolenoid1;
std::shared_ptr<DoubleSolenoid> RobotMap::ballCollectorcollectorSolenoid2;
std::shared_ptr<SpeedController> RobotMap::magiKarpetbeltMotor;
std::shared_ptr<SpeedController> RobotMap::feederfeederWheel;
std::shared_ptr<SpeedController> RobotMap::shootershooterWheelPrimary;
std::shared_ptr<SpeedController> RobotMap::shootershooterWheelBooster;
std::shared_ptr<Encoder> RobotMap::shootershooterEncoderPrimary;
std::shared_ptr<Encoder> RobotMap::shootershooterEncoderBooster;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=ALLOCATION

void RobotMap::init() {
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
    LiveWindow *lw = LiveWindow::GetInstance();

    driveTraindBaseEncoderL.reset(new Encoder(CHANNEL_A_LEFT_BASE_ENCODER, CHANNEL_B_LEFT_BASE_ENCODER, false, Encoder::k4X));
    lw->AddSensor("DriveTrain", "dBaseEncoderL", driveTraindBaseEncoderL);
    driveTraindBaseEncoderL->SetDistancePerPulse(1.0);
    driveTraindBaseEncoderL->SetPIDSourceType(PIDSourceType::kRate);
    driveTraindBaseEncoderR.reset(new Encoder(CHANNEL_A_RIGHT_BASE_ENCODER, CHANNEL_B_RIGHT_BASE_ENCODER, false, Encoder::k4X));
    lw->AddSensor("DriveTrain", "dBaseEncoderR", driveTraindBaseEncoderR);
    driveTraindBaseEncoderR->SetDistancePerPulse(1.0);
    driveTraindBaseEncoderR->SetPIDSourceType(PIDSourceType::kRate);

    int leftPorts[3] = {DRIVE_SPEED_LEFT_1,DRIVE_SPEED_LEFT_2,DRIVE_SPEED_LEFT_3};
    MultiSpeedController *lDriveControllers = new MultiSpeedController(leftPorts, 3);
    lDriveControllers->InitMotors();
    driveTraindBaseL.reset(lDriveControllers);
    lw->AddActuator("DriveTrain", "dBaseL", std::static_pointer_cast<VictorSP>(driveTraindBaseL));
    
    int rightPorts [3] = {DRIVE_SPEED_RIGHT_1,DRIVE_SPEED_RIGHT_2,DRIVE_SPEED_RIGHT_3};
    MultiSpeedController *rDriveControllers = new MultiSpeedController(rightPorts,3);
    rDriveControllers->InitMotors();
    driveTraindBaseR.reset(rDriveControllers);
    lw->AddActuator("DriveTrain", "dBaseR", std::static_pointer_cast<VictorSP>(driveTraindBaseR));

    driveTraindBaseGyro.reset(new AnalogGyro(DRIVE_GYRO));
    lw->AddSensor("DriveTrain", "dBaseGyro", driveTraindBaseGyro);
    driveTraindBaseGyro->SetSensitivity(0.007);
    gearergearDetect.reset(new DigitalInput(GEAR_DETECTOR));
    lw->AddSensor("Gearer", "gearDetect", gearergearDetect);
    
    gearergearRoller.reset(new VictorSP(GEAR_ROLLER));
    lw->AddActuator("Gearer", "gearRoller", std::static_pointer_cast<VictorSP>(gearergearRoller));
    
    gearergearSolenoid1.reset(new DoubleSolenoid(GEAR_SOLENOID_1_FORWARD_CHANNEL, GEAR_SOLENOID_1_REVERSE_CHANNEL));
    lw->AddActuator("Gearer", "gearSolenoid1", gearergearSolenoid1);
    
    gearergearSolenoid2.reset(new DoubleSolenoid(GEAR_SOLENOID_2_FORWARD_CHANNEL, GEAR_SOLENOID_1_REVERSE_CHANNEL));
    lw->AddActuator("Gearer", "gearSolenoid2", gearergearSolenoid2);
    
    ballCollectorintakeRoller.reset(new VictorSP(INTAKE_ROLLER));
    lw->AddActuator("BallCollector", "intakeRoller", std::static_pointer_cast<VictorSP>(ballCollectorintakeRoller));
    
    ballCollectorcollectorSolenoid1.reset(new DoubleSolenoid(COLLECTOR_SOLENOID_1_FORWARD_CHANNEL, COLLECTOR_SOLENOID_1_REVERSE_CHANNEL));
    lw->AddActuator("BallCollector", "collectorSolenoid1", ballCollectorcollectorSolenoid1);
    
    ballCollectorcollectorSolenoid2.reset(new DoubleSolenoid(COLLECTOR_SOLENOID_2_FORWARD_CHANNEL, COLLECTOR_SOLENOID_2_REVERSE_CHANNEL));
    lw->AddActuator("BallCollector", "collectorSolenoid2", ballCollectorcollectorSolenoid2);
    
    magiKarpetbeltMotor.reset(new VictorSP(MAGIKARPET_BELT_MOTOR));
    lw->AddActuator("MagiKarpet", "beltMotor", std::static_pointer_cast<VictorSP>(magiKarpetbeltMotor));
    
    feederfeederWheel.reset(new VictorSP(F_WHEEL_LOW));
    lw->AddActuator("Feeder", "feederWheel", std::static_pointer_cast<VictorSP>(feederfeederWheel));
    

    
    shootershooterWheelPrimary.reset(new TalonSRX(S_WHEEL_PRIMARY));
    lw->AddActuator("Shooter", "shooterWheelPrimary", std::static_pointer_cast<TalonSRX>(shootershooterWheelPrimary));
    
    shootershooterWheelBooster.reset(new TalonSRX(S_WHEEL_BOOSTER));
    lw->AddActuator("Shooter", "shooterWheelBooster", std::static_pointer_cast<TalonSRX>(shootershooterWheelBooster));
    
    shootershooterEncoderPrimary.reset(new Encoder(S_ENCODER_A_PRIMARY, S_ENCODER_B_PRIMARY, false, Encoder::k4X));
    lw->AddSensor("Shooter", "shooterEncoderPrimary", shootershooterEncoderPrimary);
    shootershooterEncoderPrimary->SetDistancePerPulse(1.0);
    shootershooterEncoderPrimary->SetPIDSourceType(PIDSourceType::kRate);
    shootershooterEncoderBooster.reset(new Encoder(S_ENCODER_A_BOOSTER, S_ENCODER_B_BOOSTER, false, Encoder::k4X));
    lw->AddSensor("Shooter", "shooterEncoderBooster", shootershooterEncoderBooster);
    shootershooterEncoderBooster->SetDistancePerPulse(1.0);
    shootershooterEncoderBooster->SetPIDSourceType(PIDSourceType::kRate);


    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
}
