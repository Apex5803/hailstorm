// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INCLUDES
#include "RobotMap.h"
#include "LiveWindow/LiveWindow.h"
#include "Custom/MultiSpeedController.h"
#include "CANTalon.h"

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INCLUDES

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=ALLOCATION
std::shared_ptr<Encoder> RobotMap::driveTraindBaseEncoderL;



std::shared_ptr<Encoder> RobotMap::driveTraindBaseEncoderR;
std::shared_ptr<SpeedController> RobotMap::driveTraindBaseL1;
std::shared_ptr<SpeedController> RobotMap::driveTraindBaseL2;
std::shared_ptr<SpeedController> RobotMap::driveTraindBaseR1;
std::shared_ptr<SpeedController> RobotMap::driveTraindBaseR2;
std::shared_ptr<ADXRS450_Gyro> RobotMap::driveTraindBaseGyro;
std::shared_ptr<SpeedController> RobotMap::gearergearRoller;
std::shared_ptr<DoubleSolenoid> RobotMap::gearergearSolenoid1;
std::shared_ptr<DoubleSolenoid> RobotMap::gearergearSecurer;
std::shared_ptr<SpeedController> RobotMap::ballCollectorintakeRoller;
std::shared_ptr<DoubleSolenoid> RobotMap::ballCollectorcollectorSolenoid1;
std::shared_ptr<DoubleSolenoid> RobotMap::ballCollectorcollectorSolenoid2;
std::shared_ptr<SpeedController> RobotMap::magiKarpetbeltMotor;
std::shared_ptr<SpeedController> RobotMap::feederfeederWheel;
std::shared_ptr<SpeedController> RobotMap::feederfeederWheel2;
std::shared_ptr<CANTalon> RobotMap::shootershooterWheelPrimary;
std::shared_ptr<CANTalon> RobotMap::shootershooterWheelBooster;
std::shared_ptr<Encoder> RobotMap::shootershooterEncoderPrimary;
std::shared_ptr<Encoder> RobotMap::shootershooterEncoderBooster;
std::shared_ptr<Compressor> RobotMap::compressor;
std::shared_ptr<SpeedController> RobotMap::climber;
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=ALLOCATION

void RobotMap::init() {
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
    LiveWindow *lw = LiveWindow::GetInstance();

    driveTraindBaseEncoderL.reset(new Encoder(CHANNEL_A_LEFT_BASE_ENCODER, CHANNEL_B_LEFT_BASE_ENCODER, false, Encoder::k4X));
    lw->AddSensor("DriveTrain", "dBaseEncoderL", driveTraindBaseEncoderL);
    driveTraindBaseEncoderL->SetDistancePerPulse(1.0);
    driveTraindBaseEncoderL->SetPIDSourceType(PIDSourceType::kRate);
    driveTraindBaseEncoderR.reset(new Encoder(CHANNEL_A_RIGHT_BASE_ENCODER, CHANNEL_B_RIGHT_BASE_ENCODER, false, Encoder::k4X));
    lw->AddSensor("DriveTrain", "dBaseEncoderR", driveTraindBaseEncoderR);
    driveTraindBaseEncoderR->SetDistancePerPulse(1.0);
    driveTraindBaseEncoderR->SetPIDSourceType(PIDSourceType::kRate);


    driveTraindBaseL1.reset(new VictorSP(DRIVE_SPEED_LEFT_1));
    driveTraindBaseL1->SetInverted(true);
    lw->AddActuator("DriveTrain", "dBaseL1", std::static_pointer_cast<VictorSP>(driveTraindBaseL1));

    driveTraindBaseL2.reset(new VictorSP(DRIVE_SPEED_LEFT_2));
    driveTraindBaseL2->SetInverted(true);
    lw->AddActuator("DriveTrain", "dBaseL2", std::static_pointer_cast<VictorSP>(driveTraindBaseL2));

    driveTraindBaseR1.reset(new VictorSP(DRIVE_SPEED_RIGHT_1));
    driveTraindBaseR1->SetInverted(false);
    lw->AddActuator("DriveTrain", "dBaseR1", std::static_pointer_cast<VictorSP>(driveTraindBaseR1));
    
    driveTraindBaseR2.reset(new VictorSP(DRIVE_SPEED_RIGHT_2));
    driveTraindBaseR2->SetInverted(false);
    lw->AddActuator("DriveTrain", "dBaseR2", std::static_pointer_cast<VictorSP>(driveTraindBaseR2));

    driveTraindBaseGyro.reset(new ADXRS450_Gyro(SPI::Port::kOnboardCS2));
    lw->AddSensor("DriveTrain", "dBaseGyro", driveTraindBaseGyro);
    driveTraindBaseGyro->Calibrate(); // Calibrate the gyro while the robot is at rest

    //gearergearDetect.reset(new DigitalInput(GEAR_DETECTOR));
    //lw->AddSensor("Gearer", "gearDetect", gearergearDetect);
    
    gearergearRoller.reset(new VictorSP(GEAR_ROLLER));
    lw->AddActuator("Gearer", "gearRoller", std::static_pointer_cast<VictorSP>(gearergearRoller));
    
    gearergearSolenoid1.reset(new DoubleSolenoid(GEAR_SOLENOID_1_FORWARD_CHANNEL, GEAR_SOLENOID_1_REVERSE_CHANNEL));
    lw->AddActuator("Gearer", "gearSolenoid1", gearergearSolenoid1);

    gearergearSecurer.reset(new DoubleSolenoid(GEAR_SECURE_SOLENOID_FORWARD_CHANNEL, GEAR_SECURE_SOLENOID_REVERSE_CHANNEL));
    lw->AddActuator("Gearer", "gearSecurer", gearergearSecurer);
    
    //gearergearSolenoid2.reset(new DoubleSolenoid(GEAR_SOLENOID_2_FORWARD_CHANNEL, GEAR_SOLENOID_1_REVERSE_CHANNEL));
    //lw->AddActuator("Gearer", "gearSolenoid2", gearergearSolenoid2);
    
    ballCollectorintakeRoller.reset(new VictorSP(INTAKE_ROLLER));
    lw->AddActuator("BallCollector", "intakeRoller", std::static_pointer_cast<VictorSP>(ballCollectorintakeRoller));
    
    ballCollectorcollectorSolenoid1.reset(new DoubleSolenoid(COLLECTOR_SOLENOID_1_FORWARD_CHANNEL, COLLECTOR_SOLENOID_1_REVERSE_CHANNEL));
    lw->AddActuator("BallCollector", "collectorSolenoid1", ballCollectorcollectorSolenoid1);
    
    ballCollectorcollectorSolenoid2.reset(new DoubleSolenoid(COLLECTOR_SOLENOID_2_FORWARD_CHANNEL, COLLECTOR_SOLENOID_2_REVERSE_CHANNEL));
    lw->AddActuator("BallCollector", "collectorSolenoid2", ballCollectorcollectorSolenoid2);
    
    magiKarpetbeltMotor.reset(new VictorSP(MAGIKARPET_BELT_MOTOR));
    lw->AddActuator("MagiKarpet", "beltMotor", std::static_pointer_cast<VictorSP>(magiKarpetbeltMotor));
    
    feederfeederWheel.reset(new VictorSP(F_WHEEL_LOW));
    lw->AddActuator("Feeder", "feederWheel", std::static_pointer_cast<VictorSP>(feederfeederWheel));
    feederfeederWheel->SetInverted(true);

    
    feederfeederWheel2.reset(new VictorSP(F_WHEEL_HIGH));
    lw->AddActuator("Feeder2", "feederWheel2", std::static_pointer_cast<VictorSP>(feederfeederWheel2));

    shootershooterWheelPrimary.reset(new CANTalon(S_WHEEL_PRIMARY));
    lw->AddActuator("Shooter", "shooterWheelPrimary", std::static_pointer_cast<CANTalon>(shootershooterWheelPrimary));
    
    shootershooterWheelBooster.reset(new CANTalon(S_WHEEL_BOOSTER));
    shootershooterWheelBooster->SetInverted(true);
    lw->AddActuator("Shooter", "shooterWheelBooster", std::static_pointer_cast<CANTalon>(shootershooterWheelBooster));
    
    shootershooterEncoderPrimary.reset(new Encoder(S_ENCODER_A_PRIMARY, S_ENCODER_B_PRIMARY, false, Encoder::k4X));
    lw->AddSensor("Shooter", "shooterEncoderPrimary", shootershooterEncoderPrimary);
    shootershooterEncoderPrimary->SetDistancePerPulse(1.0);
    shootershooterEncoderPrimary->SetPIDSourceType(PIDSourceType::kRate);
    shootershooterEncoderBooster.reset(new Encoder(S_ENCODER_A_BOOSTER, S_ENCODER_B_BOOSTER, false, Encoder::k4X));
    lw->AddSensor("Shooter", "shooterEncoderBooster", shootershooterEncoderBooster);
    shootershooterEncoderBooster->SetDistancePerPulse(1.0);
    shootershooterEncoderBooster->SetPIDSourceType(PIDSourceType::kRate);


    compressor.reset(new Compressor(0));

    climber.reset(new VictorSP(C_MOTOR));
    climber->SetInverted(false);
    lw->AddActuator("Climber", "climber", std::static_pointer_cast<VictorSP>(climber));

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
}
